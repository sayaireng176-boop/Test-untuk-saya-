
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local plr = Players.LocalPlayer

local model = game:GetObjects("rbxassetid://17523790773")[1]
local monkyContainer = model:FindFirstChild("MonkyContainer")
local mobChar = monkyContainer and monkyContainer:FindFirstChild("Main") and monkyContainer.Main:FindFirstChild("Monky")
local swing2 = monkyContainer:WaitForChild("Main"):WaitForChild("Swing2")
local swing1 = monkyContainer:WaitForChild("Main"):WaitForChild("Swing1")

mobChar.Parent = workspace
mobChar.Name = plr.Name

local humanoid = mobChar:WaitForChild("Humanoid")
local hrp = mobChar:WaitForChild("HumanoidRootPart")

hrp.CFrame = plr.Character.HumanoidRootPart.CFrame + Vector3.new(0,40,0)

humanoid.MaxHealth = 999999999
humanoid.Health = 999999999
humanoid.WalkSpeed = 32
humanoid.JumpPower = 200
humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None

local oldChar = plr.Character
plr.Character = mobChar

local cam = workspace.CurrentCamera
cam.CameraSubject = humanoid
cam.CFrame = hrp.CFrame

if oldChar and oldChar ~= mobChar then
    oldChar:Destroy()
end

if monkyContainer then
    local mainModule = monkyContainer:FindFirstChild("MainModule")
    if mainModule then
        mainModule:Destroy()
    end
end

wait(0.6)

local animators = setmetatable({},{__mode = "k"})
local FPS = 60
local secsPerFrame = 1/FPS
local blankPoses = true

local priorityOrder = {
    [Enum.AnimationPriority.Core] = 1,
    [Enum.AnimationPriority.Idle] = 2,
    [Enum.AnimationPriority.Movement] = 3,
    [Enum.AnimationPriority.Action] = 4,
    [Enum.AnimationPriority.Action2] = 5,
    [Enum.AnimationPriority.Action3] = 6,
    [Enum.AnimationPriority.Action4] = 7,
}

local ArtificialHB = Instance.new("BindableEvent")
ArtificialHB.Name = "Heartbeat"

local tf = 0
local allowframeloss = false
local tossremainder = false
local frame = 1/FPS
local maxFrameFix = 10
ArtificialHB:Fire()
local doquick = false

game:GetService("RunService").Heartbeat:Connect(function(s, p)
    tf += s
    if tf >= frame then
        local maxFrames = math.min(maxFrameFix, math.floor(tf / frame))
        if allowframeloss then
            ArtificialHB:Fire()
        else
            for i = 1, maxFrames do
                ArtificialHB:Fire()
            end
        end
        if tossremainder then
            tf = 0
        else
            tf -= frame * maxFrames
        end
    end
end)

local function swait(num)
    if num == 0 or num == nil then
        ArtificialHB.Event:Wait()
    else
        for _ = 1, num do
            ArtificialHB.Event:Wait()
        end
    end
end

local function cfSort(t1,t2)
    if t1[3] == t2[3] then
        return t1[4] < t2[4]
    else
        return t1[3] < t2[3]
    end
end

local function processAnimators()
    local toProcess = {}
    for animator in animators do table.insert(toProcess,animator) end

    local motorCFTable = {}

    for _,animator in ipairs(toProcess) do
        local motors = animator.Motors
        local tracksClone = table.clone(animator.Tracks)

        for _,track in pairs(tracksClone) do
            local weight = track.Weight
            if weight == 0 then continue end
            track.StepTime += secsPerFrame*track.Speed

            for _,keyframe in pairs(track.Keyframes) do
                if keyframe.Time > track.LastStepTime and keyframe.Time <= track.StepTime then
                    track.KeyframeReached:Fire(keyframe.Name)
                end
            end

            if track.StepTime > track.Length then
                if track.Loop then
                    track.LastStepTime = 0
                    track.StepTime = track.StepTime % track.Length
                    track.KeyframeReached:Fire(track.Keyframes[1].Name)
                elseif not track.StopFlag then
                    track:Stop(0.3)
                end
            end

            local gotMotors = {}
            for motorName,poses in pairs(track.Poses) do
                local workPose = poses[1]
                local workPoseIndex = 1

                for i = 2,#poses do
                    local pose = poses[i]
                    if track.StepTime >= pose[1] then
                        workPose = pose
                        workPoseIndex = i
                    else
                        break
                    end
                end

                local poseTime,poseInst = workPose[1],workPose[2]

                local motor = motors[motorName]
                local c00 = motor.c
                local originalmotor = motor
                motor = motor.m
                if not motor then continue end

                local poseCF = poseInst.CFrame
                local motorCFs = motorCFTable[originalmotor]
                if not motorCFs then
                    motorCFs = {}
                    motorCFTable[originalmotor] = motorCFs
                end

                local lerpedCF
                local nextPose = poses[workPoseIndex+1]
                if not nextPose then
                    lerpedCF = poseCF
                else
                    local delta = (track.StepTime - poseTime)/(nextPose[1] - poseTime)
                    lerpedCF = poseCF:Lerp(nextPose[2].CFrame,delta)
                end

                table.insert(motorCFs,{weight,lerpedCF,priorityOrder[track.Priority],track.PlayTime})
                gotMotors[motor] = true
            end

            if blankPoses then
                for _,motor in motors do
                    if gotMotors[motor.m] then continue end
                    local motorCFs = motorCFTable[motor]
                    if not motorCFs then
                        motorCFs = {}
                        motorCFTable[motor] = motorCFs
                    end
                    table.insert(motorCFs,{weight,CFrame.identity,priorityOrder[track.Priority],track.PlayTime})
                end
            end

            track.LastStepTime = track.StepTime
        end
    end

    for motor,cframes in pairs(motorCFTable) do
        table.sort(cframes,cfSort)
        local c00 = motor.c
        local motor6d = motor.m

        for _,cframe in ipairs(cframes) do
            local speed = math.clamp(cframe[1],0,1)
            if doquick then speed = 1 end
            motor6d.C0 = motor6d.C0:Lerp(c00 * cframe[2],speed)
        end
    end
    doquick = false
end

ArtificialHB.Event:Connect(processAnimators)

local classes = {}

classes.Signal = (function()
    local funcs = {}
    local disconnect = function(con)
        local pos = table.find(con.Signal.Connections,con)
        if pos then table.remove(con.Signal.Connections,pos) end
    end
    funcs.Connect = function(self,func)
        local con = {Signal=self,Func=func,Disconnect=disconnect}
        self.Connections[#self.Connections+1] = con
        return con
    end
    funcs.Fire = function(self,...)
        for _,v in next,self.Connections do
            task.spawn(v.Func,...)
        end
    end
    local mt = {__index = funcs}
    local function new()
        local self = {Connections={}}
        return setmetatable(self,mt)
    end
    return {new = new}
end)()

classes.Track = (function()
    local funcs = {}
    local mt = {__index = funcs}

    local function initPoses(self)
        local poses = self.Poses
        for _,v in pairs(self.KeyframeSequence:GetChildren()) do
            local keyTime = v.Time
            for _,pose in pairs(v:GetDescendants()) do
                if pose:IsA("Pose") and pose.Weight > 0 then
                    local poseTable = poses[pose.Name]
                    if not poseTable then
                        poseTable = {}
                        poses[pose.Name] = poseTable
                    end
                    table.insert(poseTable,{keyTime,pose})
                end
            end
            if keyTime > self.Length then
                self.Length = keyTime
            end
            table.insert(self.Keyframes,v)
        end
        for _,v in pairs(poses) do
            table.sort(v,function(a,b) return a[1] < b[1] end)
        end
    end

    local function fadeWeight(self,target,secs)
        local startTime = tick()
        local endTime = startTime+secs
        local startWeight = self.Weight
        self.LastFade = startTime
        task.spawn(function()
            while true do
                if self.LastFade ~= startTime then return end
                local curTime = tick()
                if curTime >= endTime then break end
                local frac = (curTime - startTime)/(endTime - startTime)
                self.Weight = startWeight + (target - startWeight)*frac
                task.wait()
            end
            self.Weight = target
            if target == 0 then
                local foundInd = table.find(self.Animator.Tracks,self)
                if foundInd then
                    table.remove(self.Animator.Tracks,foundInd)
                end
            end
        end)
    end

    funcs.Play = function(self,fadeTime,weight,speed)
        self.Speed = speed or 1
        self.PlayTime = tick()
        if not self.Loop or self.Weight == 0 then
            self.LastStepTime = 0
            self.StepTime = 0
        end
        self.StopFlag = false
        self.IsPlaying = true
        fadeWeight(self,weight or 1,fadeTime or 0.1)
        doquick = true
        if not table.find(self.Animator.Tracks,self) then
            table.insert(self.Animator.Tracks,self)
        end
    end

    funcs.Stop = function(self,fadeTime)
        self.StopFlag = true
        self.IsPlaying = false
        fadeWeight(self,0,fadeTime or 0.1)
        self.Stopped:Fire()
    end

    local function new(animator,keyframeSeq)
        local self = setmetatable({
            Poses = {},
            Keyframes = {},
            Speed = 1,
            Weight = 0,
            LastStepTime = 0,
            StepTime = 0,
            Length = 0,
            Loop = keyframeSeq.Loop,
            LastFade = 0,
            PlayTime = 0,
            Priority = keyframeSeq.Priority,
            KeyframeReached = classes.Signal.new(),
            KeyframeSequence = keyframeSeq,
            Animator = animator,
            IsPlaying = false,
            Stopped = classes.Signal.new()
        },mt)
        initPoses(self)
        return self
    end

    return {new = new}
end)()

classes.Animator = (function()
    local funcs = {}
    local mt = {__index = funcs}

    funcs.InitMotors = function(self)
        for _,v in pairs(self.Model:GetDescendants()) do
            if v:IsA("Motor6D") then
                self.Motors[v.Part1.Name] = {m=v,c=v.C0}
            elseif v:IsA("Bone") then
                self.Motors[v.Name] = {m=v,c=CFrame.new()}
            end
        end
    end

    funcs.LoadAnimation = function(self,keyframeSeq)
        local newTrack = classes.Track.new(self,keyframeSeq)
        return newTrack
    end

    local function new(model)
        local self = setmetatable({
            Tracks = {},
            Motors = {},
            Model = model
        },mt)
        self:InitMotors()
        animators[self] = true
        return self
    end

    return {new = new}
end)()

local function createAnimator(model)
    return classes.Animator.new(model)
end

local char = plr.Character or plr.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")
local mobChar = char
local animsFolder = mobChar:WaitForChild("Anims")
local animator = createAnimator(mobChar)

local currentTrack
local currentAnimName

local function playKeyframeSequence(seq)
    if currentAnimName == seq.Name then
        return
    end
    if currentTrack then
        currentTrack:Stop(0.2)
    end
    local track = animator:LoadAnimation(seq)
    track:Play(0.2,1,1)
    currentTrack = track
    currentAnimName = seq.Name
    return track
end

local function updateAnimation()
    local state = humanoid:GetState()
    if humanoid.MoveDirection.Magnitude > 0 then
        playKeyframeSequence(animsFolder:WaitForChild("Walk"))
    elseif state == Enum.HumanoidStateType.Jumping or state == Enum.HumanoidStateType.Freefall then
        playKeyframeSequence(animsFolder:WaitForChild("Fall"))
    else
        playKeyframeSequence(animsFolder:WaitForChild("Idle"))
    end
end

local function Finished()
    local state = humanoid:GetState()
    if humanoid.MoveDirection.Magnitude > 0 then
        playKeyframeSequence(animsFolder:WaitForChild("Walk"))
    elseif state == Enum.HumanoidStateType.Jumping or state == Enum.HumanoidStateType.Freefall then
        playKeyframeSequence(animsFolder:WaitForChild("Fall"))
    else
        playKeyframeSequence(animsFolder:WaitForChild("Idle"))
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.Z then
        local stompSeq = animsFolder:FindFirstChild("Stomp")
        if not stompSeq then return end
        local stompTrack = playKeyframeSequence(stompSeq)
        if stompTrack then
            stompTrack.Loop = false
            local conn
            conn = stompTrack.Stopped:Connect(function()
                conn:Disconnect()
                task.spawn(function()
                    if currentTrack == stompTrack then
                        Finished()
                    end
                end)
            end)
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.X then
        local stompSeq = animsFolder:FindFirstChild("Swipe")
        if not stompSeq then return end
        local stompTrack = playKeyframeSequence(stompSeq)
        if stompTrack then
            stompTrack.Loop = false
            local conn
            conn = stompTrack.Stopped:Connect(function()
                conn:Disconnect()
                task.spawn(function()
                    if currentTrack == stompTrack then
                        Finished()
                    end
                end)
            end)
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.F then
        local stompSeq = animsFolder:FindFirstChild("Hurl")
        if not stompSeq then return end
        local stompTrack = playKeyframeSequence(stompSeq)
        if stompTrack then
            stompTrack.Loop = false
            local conn
            conn = stompTrack.Stopped:Connect(function()
                conn:Disconnect()
                task.spawn(function()
                    if currentTrack == stompTrack then
                        Finished()
                    end
                end)
            end)
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.C then
        local stompSeq = animsFolder:FindFirstChild("Grab")
        if not stompSeq then return end
        local stompTrack = playKeyframeSequence(stompSeq)
        if stompTrack then
            stompTrack.Loop = false
            local conn
            conn = stompTrack.Stopped:Connect(function()
                conn:Disconnect()
                task.spawn(function()
                    if currentTrack == stompTrack then
                        Finished()
                    end
                end)
            end)
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.V then
        local stompSeq = animsFolder:FindFirstChild("Throw")
        if not stompSeq then return end
        local stompTrack = playKeyframeSequence(stompSeq)
        if stompTrack then
            stompTrack.Loop = false
            local conn
            conn = stompTrack.Stopped:Connect(function()
                conn:Disconnect()
                task.spawn(function()
                    if currentTrack == stompTrack then
                        Finished()
                    end
                end)
            end)
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.B then
        local stompSeq = animsFolder:FindFirstChild("Punt")
        if not stompSeq then return end
        local stompTrack = playKeyframeSequence(stompSeq)
        if stompTrack then
            stompTrack.Loop = false
            local conn
            conn = stompTrack.Stopped:Connect(function()
                conn:Disconnect()
                task.spawn(function()
                    if currentTrack == stompTrack then
                        Finished()
                    end
                end)
            end)
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.N then
        local stompSeq = animsFolder:FindFirstChild("TripleStomp")
        if not stompSeq then return end
        local stompTrack = playKeyframeSequence(stompSeq)
        if stompTrack then
            stompTrack.Loop = false
            local conn
            conn = stompTrack.Stopped:Connect(function()
                conn:Disconnect()
                task.spawn(function()
                    if currentTrack == stompTrack then
                        Finished()
                    end
                end)
            end)
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.M then
        local stompSeq = animsFolder:FindFirstChild("Execute")
        if not stompSeq then return end
        local stompTrack = playKeyframeSequence(stompSeq)
        if stompTrack then
            stompTrack.Loop = false
            local conn
            conn = stompTrack.Stopped:Connect(function()
                conn:Disconnect()
                task.spawn(function()
                    if currentTrack == stompTrack then
                        Finished()
                    end
                end)
            end)
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.G then
        local stompSeq = animsFolder:FindFirstChild("LeapHurl")
        if not stompSeq then return end
        local stompTrack = playKeyframeSequence(stompSeq)
        if stompTrack then
            stompTrack.Loop = false
            local conn
            conn = stompTrack.Stopped:Connect(function()
                conn:Disconnect()
                task.spawn(function()
                    if currentTrack == stompTrack then
                        Finished()
                    end
                end)
            end)
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.J then
        local stompSeq = animsFolder:FindFirstChild("Awaken")
        if not stompSeq then return end
        local stompTrack = playKeyframeSequence(stompSeq)
        if stompTrack then
            stompTrack.Loop = false
            local conn
            conn = stompTrack.Stopped:Connect(function()
                conn:Disconnect()
                task.spawn(function()
                    if currentTrack == stompTrack then
                        Finished()
                    end
                end)
            end)
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if input.KeyCode == Enum.KeyCode.H then
        local stompSeq = animsFolder:FindFirstChild("MidPunch")
        if not stompSeq then return end
        local stompTrack = playKeyframeSequence(stompSeq)
        if stompTrack then
            stompTrack.Loop = false
            local conn
            conn = stompTrack.Stopped:Connect(function()
                conn:Disconnect()
                task.spawn(function()
                    if currentTrack == stompTrack then
                        Finished()
                    end
                end)
            end)
        end
    end
end)

humanoid.Running:Connect(updateAnimation)
humanoid.StateChanged:Connect(updateAnimation)
updateAnimation()

-- Gui
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local ControllerGui = Instance.new("ScreenGui")
ControllerGui.Name = "ControllerGui"
ControllerGui.Parent = player:WaitForChild("PlayerGui")

local TextBoxTemplate = Instance.new("Frame")
TextBoxTemplate.Name = "TextBoxTemplate"
TextBoxTemplate.Parent = ControllerGui
TextBoxTemplate.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextBoxTemplate.BackgroundTransparency = 1
TextBoxTemplate.BorderColor3 = Color3.fromRGB(27, 42, 53)
TextBoxTemplate.BorderSizePixel = 1
TextBoxTemplate.Position = UDim2.new(0, 0, 0, 0)
TextBoxTemplate.Size = UDim2.new(1, 0, 0, 50)
TextBoxTemplate.AnchorPoint = Vector2.new(0, 0)
TextBoxTemplate.Visible = false
TextBoxTemplate.ZIndex = 1
TextBoxTemplate.ClipsDescendants = false
TextBoxTemplate.LayoutOrder = 0
TextBoxTemplate.Active = false

local Box = Instance.new("TextBox")
Box.Name = "Box"
Box.Parent = TextBoxTemplate
Box.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Box.BackgroundTransparency = 0
Box.BorderColor3 = Color3.fromRGB(30, 30, 30)
Box.BorderSizePixel = 0
Box.Position = UDim2.new(0, 5, 0, 20)
Box.Size = UDim2.new(1, -10, 0, 25)
Box.Font = Enum.Font.SourceSans
Box.Text = ""
Box.TextColor3 = Color3.fromRGB(255, 255, 255)
Box.TextSize = 14
Box.TextScaled = false
Box.TextWrapped = false
Box.TextTransparency = 0
Box.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
Box.TextStrokeTransparency = 1
Box.AnchorPoint = Vector2.new(0, 0)
Box.Visible = true
Box.ZIndex = 1
Box.ClipsDescendants = false
Box.LayoutOrder = 0
Box.ClearTextOnFocus = true
Box.PlaceholderText = ""
Box.PlaceholderColor3 = Color3.fromRGB(200, 200, 200)
Box.MultiLine = false
Box.Active = true
Box.LineHeight = 1
Box.CursorPosition = 1
Box.TextEditable = true
Box.MaxVisibleGraphemes = -1

local UICorner = Instance.new("UICorner")
UICorner.Name = "UICorner"
UICorner.Parent = Box

local TextLabel = Instance.new("TextLabel")
TextLabel.Name = "TextLabel"
TextLabel.Parent = TextBoxTemplate
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1
TextLabel.BorderColor3 = Color3.fromRGB(27, 42, 53)
TextLabel.BorderSizePixel = 1
TextLabel.Position = UDim2.new(0, 5, 0, 0)
TextLabel.Size = UDim2.new(1, -10, 0, 20)
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = "Speed"
TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.TextSize = 14
TextLabel.TextScaled = false
TextLabel.TextWrapped = false
TextLabel.TextTransparency = 0
TextLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.TextStrokeTransparency = 1
TextLabel.AnchorPoint = Vector2.new(0, 0)
TextLabel.Visible = true
TextLabel.ZIndex = 1
TextLabel.ClipsDescendants = false
TextLabel.LayoutOrder = 0
TextLabel.Active = false
TextLabel.LineHeight = 1
TextLabel.MaxVisibleGraphemes = -1

local Frame = Instance.new("Frame")
Frame.Name = "Frame"
Frame.Parent = ControllerGui
Frame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
Frame.BackgroundTransparency = 0
Frame.BorderColor3 = Color3.fromRGB(27, 42, 53)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.05000000074505806, 0, 0.6000000238418579, 0)
Frame.Size = UDim2.new(0, 150, 0, 165)
Frame.AnchorPoint = Vector2.new(0, 0)
Frame.Visible = true
Frame.ZIndex = 1
Frame.ClipsDescendants = false
Frame.LayoutOrder = 0
Frame.Active = true

local UICorner = Instance.new("UICorner")
UICorner.Name = "UICorner"
UICorner.Parent = Frame

local Title = Instance.new("TextLabel")
Title.Name = "Title"
Title.Parent = Frame
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1
Title.BorderColor3 = Color3.fromRGB(27, 42, 53)
Title.BorderSizePixel = 1
Title.Position = UDim2.new(0, 5, 0, 0)
Title.Size = UDim2.new(1, -10, 0, 25)
Title.Font = Enum.Font.SourceSansBold
Title.Text = "Grandosla"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 14
Title.TextScaled = false
Title.TextWrapped = false
Title.TextTransparency = 0
Title.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
Title.TextStrokeTransparency = 1
Title.AnchorPoint = Vector2.new(0, 0)
Title.Visible = true
Title.ZIndex = 1
Title.ClipsDescendants = false
Title.LayoutOrder = 0
Title.Active = false
Title.LineHeight = 1
Title.MaxVisibleGraphemes = -1

local ButtonTemplate = Instance.new("TextButton")
ButtonTemplate.Name = "ButtonTemplate"
ButtonTemplate.Parent = ControllerGui
ButtonTemplate.BackgroundColor3 = Color3.fromRGB(0, 135, 203)
ButtonTemplate.BackgroundTransparency = 0
ButtonTemplate.BorderColor3 = Color3.fromRGB(27, 42, 53)
ButtonTemplate.BorderSizePixel = 1
ButtonTemplate.Position = UDim2.new(0, 5, 1, -140)
ButtonTemplate.Size = UDim2.new(1, -10, 0, 25)
ButtonTemplate.Font = Enum.Font.SourceSans
ButtonTemplate.Text = "Power On/Off"
ButtonTemplate.TextColor3 = Color3.fromRGB(255, 255, 255)
ButtonTemplate.TextSize = 14
ButtonTemplate.TextScaled = false
ButtonTemplate.TextWrapped = false
ButtonTemplate.TextTransparency = 0
ButtonTemplate.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
ButtonTemplate.TextStrokeTransparency = 1
ButtonTemplate.AnchorPoint = Vector2.new(0, 0)
ButtonTemplate.Visible = false
ButtonTemplate.ZIndex = 1
ButtonTemplate.ClipsDescendants = false
ButtonTemplate.LayoutOrder = 0
ButtonTemplate.Active = true
ButtonTemplate.LineHeight = 1
ButtonTemplate.MaxVisibleGraphemes = -1

local UICorner = Instance.new("UICorner")
UICorner.Name = "UICorner"
UICorner.Parent = ButtonTemplate

wait(0.1)
 
local plr = game:GetService("Players").LocalPlayer
local mouse = plr:GetMouse()
local char = plr.Character
 
local UIS = game:GetService("UserInputService")
 
-- Gui Lib --
local gui = player:WaitForChild("PlayerGui"):WaitForChild("ControllerGui")
local frame = gui:WaitForChild("Frame")
 
local initSize = 25
local buttonSize = 30
local textBoxSize = 50
local baseWidth = 150
local buttonTemplate = gui:WaitForChild("ButtonTemplate")
local textBoxTemplate = gui:WaitForChild("TextBoxTemplate")
local nextPosition = initSize
 
local function setTitle(text)
    frame:WaitForChild("Title").Text = text
end
 
local function newButton(text,clickFunc)
    local newButtonGui = buttonTemplate:Clone()
    newButtonGui.Position = UDim2.new(0,5,0,nextPosition)
    nextPosition = nextPosition + buttonSize
    
    newButtonGui.Text = text
    newButtonGui.Visible = true
    
    if clickFunc then
        newButtonGui.MouseButton1Click:Connect(clickFunc)
    end
    
    frame.Size = UDim2.new(0,150,0,nextPosition)
    newButtonGui.Parent = frame
    
    return newButtonGui
end
 
local function newTextBox(label,defaultText,changedFunc)
    local newFrame = textBoxTemplate:Clone()
    newFrame.Position = UDim2.new(0,0,0,nextPosition)
    nextPosition = nextPosition + textBoxSize
    
    newFrame.TextLabel.Text = label
    newFrame.Box.Text = defaultText or ""
    newFrame.Visible = true
    
    if changedFunc then
        newFrame.Box.FocusLost:Connect(function()
            changedFunc(newFrame.Box.Text)
        end)
    end
    
    frame.Size = UDim2.new(0,150,0,nextPosition)
    newFrame.Parent = frame
    
    return newFrame
end
 
local mouse = game:GetService("Players").LocalPlayer:GetMouse()
frame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local releaseEvent,mouseEvent
        
        local initX = frame.AbsolutePosition.X
        local initY = frame.AbsolutePosition.Y
        local offX = mouse.X - initX
        local offY = mouse.Y - initY
        
        releaseEvent = UIS.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                releaseEvent:Disconnect()
                mouseEvent:Disconnect()
            end
        end)
        
        mouseEvent = UIS.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                local inputX,inputY = input.Position.X,input.Position.Y
                local posX,posY = inputX-offX,inputY-offY
                frame.Position = UDim2.new(0,posX,0,posY)
            end
        end)
    end
end)
 
----------------------------------------------
 
local sets = {
DestroyParts = true,
DestroyAnchored = false,
MaxMass = 0,
SplitParts = true,
DestructiveWalk = false,
}
 
local anchoredButton,anchoredBox,splitButton,walkButton,partsButton
local function updateButtons()
    anchoredButton.Text = "Destroyed Anchored: "..tostring(sets.DestroyAnchored)
    anchoredBox.Box.Text = tostring(sets.MaxMass)
    splitButton.Text = "Split Parts: "..tostring(sets.SplitParts)
    walkButton.Text = "Destructive Walk: "..tostring(sets.DestructiveWalk)
    partsButton.Text = "Destroy Parts: "..tostring(sets.DestroyParts)
end
 
setTitle("Monky")
 
cleanButton = newButton("Clean Parts",function()
    print(" ")
end)
 
partsButton = newButton("Destroy Parts",function()
    sets.DestroyParts = not sets.DestroyParts
    partsButton.Text = "Destroy Parts: "..tostring(sets.DestroyParts)
end)
 
splitButton = newButton("Split Parts",function()
    sets.SplitParts = not sets.SplitParts
    splitButton.Text = "Split Parts: "..tostring(sets.SplitParts)
end)
 
walkButton = newButton("Destructive Walk",function()
    sets.DestructiveWalk = not sets.DestructiveWalk
    walkButton.Text = "Destructive Walk: "..tostring(sets.DestructiveWalk)
end)
 
anchoredButton = newButton("Destroyed Anchored",function()
    sets.DestroyAnchored = not sets.DestroyAnchored
    anchoredButton.Text = "Destroyed Anchored: "..tostring(sets.DestroyAnchored)
end)
 
anchoredBox = newTextBox("Max Anchored Mass","",function()
    sets.MaxMass = tonumber(anchoredBox.Box.Text) or 0
    anchoredBox.Box.Text = tostring(sets.MaxMass)
end)
 
updateButtons()
 
 
 
local h,t
local normalMap = {}
 
for i,v in pairs(Enum.NormalId:GetEnumItems()) do
    local vec = Vector3.FromNormalId(v)
    normalMap[vec] = v
end
 
local function isFiltered(obj)
    return not obj.CanCollide
end
 
while task.wait(1/60) do
    local Mouse = mouse
    local Target,Hit
    local TargetSurface = Enum.NormalId.Right
    
    local filterList = {plr.Character}
    
    while true do
        local params = RaycastParams.new()
        params.FilterType = Enum.RaycastFilterType.Blacklist
        params.FilterDescendantsInstances = filterList
        
        local res = workspace:Raycast(Mouse.Origin.Position,Mouse.Origin.LookVector*100000,params)
        if res then
            local objectNormal = res.Instance.CFrame:ToObjectSpace(res.Instance.CFrame + res.Normal).p
            objectNormal = Vector3.new(math.round(objectNormal.X), math.round(objectNormal.Y), math.round(objectNormal.Z))
            
            local inst = res.Instance
            if isFiltered(inst) then
                table.insert(filterList,inst)
                continue
            else
                Target = inst
                
                if objectNormal.Magnitude > 1 then
                    objectNormal = objectNormal * Vector3.new(0,1,1)
                    if objectNormal.Magnitude > 1 then
                        objectNormal = objectNormal * Vector3.new(0,0,1)
                    end
                end
                
                TargetSurface = normalMap[objectNormal]
                Hit = CFrame.new(res.Position,res.Position + Mouse.Origin.LookVector)
                break
            end
        else
            break
        end
    end
    
    Hit = Hit or Mouse.Hit
    
    if h~=Hit or t~=Target then
        event:Fire("MousePos",Hit,Target)
        h,t=Hit,Target
    end
end